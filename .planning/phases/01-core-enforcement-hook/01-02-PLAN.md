---
phase: 01-core-enforcement-hook
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - hooks/gsd-enforce.js
autonomous: true

must_haves:
  truths:
    - "当用户输入包含 /gsd:* 命令时，hook 在同一回合内进入 active 状态并记录命令名"
    - "任意未在映射表声明的 /gsd:* 命令会被 fail-closed（阻止回合结束并给出 remediation）"
  artifacts:
    - path: "hooks/gsd-enforce.js"
      provides: "UserPromptSubmit/Stop 事件处理 + turn 状态机（最小字段：active、command、turn_start_ms、session_id）"
  key_links:
    - from: "UserPromptSubmit"
      to: "Stop"
      via: "turn state persisted across events"
      pattern: "session_id"
    - from: "hooks/gsd-enforce.js"
      to: "command mapping"
      via: "explicit mapping for /gsd:*"
      pattern: "/gsd:"
---

<objective>
实现 GSD 命令检测与“回合状态机”的最小闭环：在 UserPromptSubmit 识别 /gsd:* 并写入 turn 状态；在 Stop 做 fail-closed 校验（未映射命令直接阻止）。

Purpose: 先把“识别与状态关联”做稳定，后续计划才能可靠地做 PreToolUse 的 fail-fast 与子代理/产物校验。
Output: hooks/gsd-enforce.js 具备 turn-scoped state（跨事件），并对未映射 /gsd:* 命令执行 fail-closed。
</objective>

<execution_context>
@/home/adam/.claude/get-shit-done/workflows/execute-plan.md
@/home/adam/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/01-core-enforcement-hook/01-CONTEXT.md
@.planning/phases/01-core-enforcement-hook/01-RESEARCH.md

@hooks/gsd-enforce.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: 在 UserPromptSubmit 识别 /gsd:* 并初始化 turn 状态</name>
  <files>hooks/gsd-enforce.js</files>
  <action>
- 在 hooks/gsd-enforce.js 中实现事件分派：读取 stdin JSON 的 hookEventName（或等价字段），按事件调用 handler。
- UserPromptSubmit：
  - 从 prompt 文本中提取第一个出现的 /gsd:* 命令（例如 /gsd:plan-phase）。
  - 写入 turn 状态：active=true、command、turn_start_ms、session_id（若字段存在）。
  - 如果本回合不是 /gsd:*，确保 active=false 并清理本回合状态（不影响非 GSD）。
- 状态持久化策略：
  - 以“session_id + event chain”作为 key，把状态写到 configDir/cache 下（而不是项目目录），避免污染 repo。
  - 写入必须尽可能原子（先写临时文件再 rename），避免部分写导致状态损坏。
- 仅实现最小字段；不要提前实现复杂校验（留给后续计划）。
  </action>
  <verify>
- 构造最小 JSON 输入（含 hookEventName=UserPromptSubmit、prompt、session_id），pipe 给 node hooks/gsd-enforce.js，确保返回 exit code 0 且不输出阻止 decision。
- 再构造 Stop 事件输入（同 session_id），确认能读取到上一事件写入的 command（可用临时 debug 输出到 stderr；正式实现最终会移除或降噪）。
  </verify>
  <done>
- /gsd:* 命令在 UserPromptSubmit 被可靠识别；非 /gsd:* 不会污染状态。
  </done>
</task>

<task type="auto">
  <name>Task 2: 建立 Phase 1 的显式命令映射并实现“未映射 fail-closed”</name>
  <files>hooks/gsd-enforce.js</files>
  <action>
- 在 hooks/gsd-enforce.js 内声明一个 Phase 1 版本的“显式映射表”（Phase 2 再外置到 JSON）：
  - 覆盖所有 /gsd:* 命令（至少把 repo 内 commands/gsd/*.md 列出来逐一映射）。
  - 对每个命令声明 required_subagent（gsd-planner / gsd-executor / none / other）与 expected_artifacts（可为 none）。
- Stop 事件：
  - 若本回合 active 且 command 以 /gsd: 开头，但不在映射表中：decision=block（fail-closed），reason 说明“需要在映射中显式声明该命令”。
  - 若命令在映射表中但 required_subagent=none：Stop 不应 block（ERR-03）。
- 输出采用 hooks 的结构化 JSON（exit code 0），不要用 exit code 2（避免 stdout JSON 被忽略的坑）。
  </action>
  <verify>
- 使用合成输入：
  - UserPromptSubmit(/gsd:does-not-exist) -> Stop：应返回 decision=block。
  - UserPromptSubmit(非 /gsd) -> Stop：应不阻止。
  - UserPromptSubmit(/gsd:help) -> Stop：若映射 required_subagent=none，应不阻止。
  </verify>
  <done>
- HOOK-03 的“命令检测”成立；fail-closed 对未映射 /gsd:* 生效；非 GSD 不误伤。
  </done>
</task>

</tasks>

<verification>
- 重点验证：状态可跨事件读写；未映射 /gsd:* 触发 block；非 /gsd 不触发。
</verification>

<success_criteria>
- hooks/gsd-enforce.js 可以在本地用模拟 stdin JSON 完成 UserPromptSubmit -> Stop 的闭环
- 未映射 /gsd:* 会被 block，映射为 none 的命令不被 block
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-enforcement-hook/01-02-SUMMARY.md`
</output>
