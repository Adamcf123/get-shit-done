---
phase: 01-core-enforcement-hook
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - hooks/gsd-enforce.js
autonomous: true

must_haves:
  truths:
    - "当用户输入包含 /gsd:* 命令时，hook 在同一回合内进入 active 状态并记录命令名"
    - "turn 状态跨事件（UserPromptSubmit -> Stop）可重复读取；状态存储位置不污染 repo，并且路径选择是确定性的"
    - "任意未在映射表声明的 /gsd:* 命令会被 fail-closed（阻止回合结束并给出 remediation）"
  artifacts:
    - path: "hooks/gsd-enforce.js"
      provides: "UserPromptSubmit/Stop 事件处理 + turn 状态机（最小字段：active、command、turn_start_ms、session_id）"
  key_links:
    - from: "UserPromptSubmit"
      to: "Stop"
      via: "turn state persisted across events"
      pattern: "session_id"
    - from: "hooks/gsd-enforce.js"
      to: "state store directory"
      via: "deterministic os.tmpdir()-based path"
      pattern: "os\.tmpdir\(\)"
    - from: "hooks/gsd-enforce.js"
      to: "command mapping"
      via: "explicit mapping for /gsd:*"
      pattern: "/gsd:"
---

<objective>
实现 GSD 命令检测与“回合状态机”的最小闭环：在 UserPromptSubmit 识别 /gsd:* 并写入 turn 状态；在 Stop 做 fail-closed 校验（未映射命令直接阻止）。

Purpose: 先把“识别与状态关联”做稳定，后续计划才能可靠地做 PreToolUse 的 fail-fast 与子代理/产物校验。
Output: hooks/gsd-enforce.js 具备 turn-scoped state（跨事件），并对未映射 /gsd:* 命令执行 fail-closed。
</objective>

<execution_context>
@/home/adam/.claude/get-shit-done/workflows/execute-plan.md
@/home/adam/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/01-core-enforcement-hook/01-CONTEXT.md
@.planning/phases/01-core-enforcement-hook/01-RESEARCH.md

@hooks/gsd-enforce.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: 在 UserPromptSubmit 识别 /gsd:* 并初始化 turn 状态</name>
  <files>hooks/gsd-enforce.js</files>
  <action>
- 在 hooks/gsd-enforce.js 中实现事件分派：读取 stdin JSON 的 hookEventName（或等价字段），按事件调用 handler。
- UserPromptSubmit：
  - 从 prompt 文本中提取第一个出现的 /gsd:* 命令（例如 /gsd:plan-phase）。
  - 写入 turn 状态：active=true、command、turn_start_ms、session_id（若字段存在）。
  - 如果本回合不是 /gsd:*，确保 active=false 并清理本回合状态（不影响非 GSD）。
- 状态持久化策略（必须是确定性的，且不依赖“未定义的 configDir/cache”）：
  - state_dir = path.join(os.tmpdir(), "gsd-enforce")（或等价固定路径）；只写这个目录，避免污染 repo。
  - state_file = path.join(state_dir, `turn-${sanitize(session_id)}.json`)。
  - sanitize 规则必须确定且可逆到“同一个 session_id 总是同一个文件名”：推荐只保留 [a-zA-Z0-9_.-]，其他字符替换为 '_'。
  - 写入必须尽可能原子：写临时文件（同目录）再 rename 覆盖，避免部分写导致状态损坏。
  - 读取失败/写入失败/JSON 解析失败必须 fail-loud（不得静默放行）：
    - Stop/PreToolUse 的 fail-loud 行为在后续计划会统一；本计划至少保证发生内部错误时，不会继续走“allow/不阻止”的路径。
- 关联键策略（deterministic）：
  - 优先使用 stdin JSON 中的 session_id。
  - 若检测到 /gsd:* 但缺失 session_id，视为 SystemFault：在可阻止的事件（Stop/PreToolUse）必须阻止；在不可结构化阻止的事件至少以非 0 退出 + stderr 明确报错（fail-loud），避免出现“绕过校验但继续执行”。
- 仅实现最小字段；不要提前实现复杂校验（留给后续计划）。
  </action>
  <verify>
- 合成最小 JSON 输入（含 hookEventName=UserPromptSubmit、prompt、session_id），pipe 给 node hooks/gsd-enforce.js，确保返回 exit code 0 且不输出阻止 decision。
- 再构造 Stop 事件输入（同 session_id），确认能读取到上一事件写入的 command（可用临时 debug 输出到 stderr；完成验证后应移除或降噪）。
- 真实输入验证（用于锁定事件 schema，避免“合成 JSON 假设错误”）：
  1) 临时让 hook 在 stderr 打印 stdin JSON 的顶层 keys（或把 stdin 原文写到 os.tmpdir()/gsd-enforce/real-<event>.json；注意不要写入完整 prompt 内容）。
  2) 在真实 Claude Code 中触发一次 GSD 回合（例如输入 /gsd:help），收集一次真实 UserPromptSubmit 与 Stop 的输入样本。
  3) 用采集到的真实 JSON 样本重放：`node hooks/gsd-enforce.js < real-UserPromptSubmit.json` 然后 `node hooks/gsd-enforce.js < real-Stop.json`，确认“同 session_id 的跨事件状态”可读。
  </verify>
  <done>
- /gsd:* 命令在 UserPromptSubmit 被可靠识别；非 /gsd:* 不会污染状态。
- state store 目录与文件名策略明确、确定、可重复；出现内部错误不会静默放行（fail-loud 路径存在）。
  </done>
</task>

<task type="auto">
  <name>Task 2: 建立 Phase 1 的显式命令映射并实现“未映射 fail-closed”</name>
  <files>hooks/gsd-enforce.js</files>
  <action>
- 在 hooks/gsd-enforce.js 内声明一个 Phase 1 版本的“显式映射表”（Phase 2 再外置到 JSON）：
  - 覆盖所有 /gsd:* 命令（至少把 repo 内 commands/gsd/*.md 列出来逐一映射）。
  - 对每个命令声明 required_subagent（gsd-planner / gsd-executor / none / other）与 expected_artifacts（可为 none）。
- Stop 事件：
  - 若本回合 active 且 command 以 /gsd: 开头，但不在映射表中：decision=block（fail-closed），reason 说明“需要在映射中显式声明该命令”。
  - 若命令在映射表中但 required_subagent=none：Stop 不应 block（ERR-03）。
- 输出采用 hooks 的结构化 JSON（exit code 0），不要用 exit code 2（避免 stdout JSON 被忽略的坑）。
  </action>
  <verify>
- 使用合成输入：
  - UserPromptSubmit(/gsd:does-not-exist) -> Stop：应返回 decision=block。
  - UserPromptSubmit(非 /gsd) -> Stop：应不阻止。
  - UserPromptSubmit(/gsd:help) -> Stop：若映射 required_subagent=none，应不阻止。
  </verify>
  <done>
- HOOK-03 的“命令检测”成立；fail-closed 对未映射 /gsd:* 生效；非 GSD 不误伤。
  </done>
</task>

</tasks>

<verification>
- 重点验证：状态可跨事件读写；状态目录选择确定且不污染 repo；未映射 /gsd:* 触发 block；非 /gsd 不触发。
</verification>

<success_criteria>
- hooks/gsd-enforce.js 可以在本地用模拟 stdin JSON 完成 UserPromptSubmit -> Stop 的闭环
- 状态存储策略明确且可重复（同 session_id 总能读回同一份 turn 状态）
- 未映射 /gsd:* 会被 block，映射为 none 的命令不被 block
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-enforcement-hook/01-02-SUMMARY.md`
</output>
