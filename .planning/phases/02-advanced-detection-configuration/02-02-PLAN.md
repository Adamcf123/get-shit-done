---
phase: 02-advanced-detection-configuration
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - hooks/gsd-enforce.js
autonomous: true

must_haves:
  truths:
    - "Hook 检测文本中的并行声明关键词并提取期望数字"
    - "Hook 在 PreToolUse 中累加 Task 调用计数"
    - "Hook 在 Stop 时校验实际调用数 vs 声明数"
    - "声称 N 个但实际只有 1 次调用时拦截"
    - "声称 N 个但实际 > 1 时不拦截（容忍部分并行）"
  artifacts:
    - path: "hooks/gsd-enforce.js"
      provides: "extractParallelClaim() + validateParallelCalls()"
      contains: "extractParallelClaim"
  key_links:
    - from: "hooks/gsd-enforce.js:handleUserPromptSubmit"
      to: "extractParallelClaim()"
      via: "提取并行声明"
      pattern: "extractParallelClaim"
    - from: "hooks/gsd-enforce.js:handlePreToolUse"
      to: "state.task_call_count"
      via: "累加 Task 调用计数"
      pattern: "task_call_count"
    - from: "hooks/gsd-enforce.js:handleStop"
      to: "validateParallelCalls()"
      via: "校验并行调用"
      pattern: "validateParallelCalls"
---

<objective>
实现假并行检测：检测 orchestrator 声称"并行启动 N 个"但实际只调用 1 次 Task 的欺骗模式。

Purpose: 满足 ENF-05/MAP-03 需求 — 防止 orchestrator 声称并行但实际串行执行。
Output: extractParallelClaim() + validateParallelCalls() 函数
</objective>

<execution_context>
@/home/adam/.claude/get-shit-done/workflows/execute-plan.md
@/home/adam/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-advanced-detection-configuration/02-CONTEXT.md
@.planning/phases/02-advanced-detection-configuration/02-RESEARCH.md
@.planning/phases/02-advanced-detection-configuration/02-01-SUMMARY.md
@hooks/gsd-enforce.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: 实现并行声明提取</name>
  <files>hooks/gsd-enforce.js</files>
  <action>
在 gsd-enforce.js 中添加并行声明提取逻辑：

1. 定义并行关键词正则模式数组（中英文）：
   ```javascript
   const PARALLEL_PATTERNS = [
     // Chinese patterns
     /(?:并行|同时)(?:启动|spawn|创建|运行)\s*(\d+)\s*个/i,
     /启动\s*(\d+)\s*个\s*(?:并行|同时)/i,

     // English patterns
     /spawn(?:ing)?\s+(\d+)\s+\w+\s+(?:in\s+)?parallel/i,
     /(\d+)\s+parallel\s+(?:agents?|researchers?|executors?|subagents?|tasks?)/i,
     /(?:run(?:ning)?|start(?:ing)?|launch(?:ing)?)\s+(\d+)\s+\w+\s+(?:in\s+)?parallel/i,
     /in\s+parallel[^.]*?(\d+)\s+(?:agents?|tasks?)/i,
   ];
   ```

2. 实现 extractParallelClaim(promptText) 函数：
   - 遍历 PARALLEL_PATTERNS，依次匹配
   - 提取捕获组中的数字
   - 仅当数字 >= 2 且 <= 100 时返回（合理边界）
   - 无匹配返回 null

3. 在 handleUserPromptSubmit 中调用：
   - 在检测到 /gsd:* 命令后，调用 extractParallelClaim(promptText)
   - 将结果存入 state.expected_parallel_count
   - 同时重置 state.task_call_count = 0（避免跨回合污染）

注意：正则必须包含并行关键词作为锚点，避免误匹配"Phase 4"等非并行数字。
  </action>
  <verify>
测试用例：
- "并行启动 4 个 researcher" => 4
- "spawn 3 agents in parallel" => 3
- "4 parallel researchers" => 4
- "Phase 4 planning" => null（无并行关键词）
- "启动 1 个" => null（< 2）
  </verify>
  <done>
extractParallelClaim() 正确提取中英文并行声明中的数字
  </done>
</task>

<task type="auto">
  <name>Task 2: 实现 Task 调用计数和并行校验</name>
  <files>hooks/gsd-enforce.js</files>
  <action>
在 gsd-enforce.js 中添加计数和校验逻辑：

1. 在 handlePreToolUse 中累加 Task 调用计数：
   - 在现有 Task 处理逻辑后（记录 delegated_subagent 之后）
   - 添加：state.task_call_count = (state.task_call_count || 0) + 1
   - 写入 turn state

2. 实现 validateParallelCalls(state) 函数：
   ```javascript
   function validateParallelCalls(state) {
     const expected = state.expected_parallel_count;
     const actual = state.task_call_count || 0;

     // No parallel claim or claim < 2
     if (!expected || expected < 2) return null;

     // Only block complete deception: claimed N but only 1 call
     if (actual === 1 && expected > 1) {
       return {
         error_code: 'USER_FAKE_PARALLEL',
         expected,
         actual,
       };
     }

     // Tolerate partial parallel (actual > 1 but < expected)
     return null;
   }
   ```

3. 在 handleStop 中调用 validateParallelCalls：
   - 在 required_subagent 校验之后、expected_artifacts 校验之前
   - 如果返回非 null，调用 stopBlock 并格式化消息：
     ```javascript
     const parallelResult = validateParallelCalls(state);
     if (parallelResult) {
       stopBlock(formatBlockMessage({
         command: state.command,
         error_code: parallelResult.error_code,
         next_step: `下一步：声称并行启动 ${parallelResult.expected} 个子代理，但实际只调用了 ${parallelResult.actual} 次 Task。请真正并行调用 Task（在同一消息中发送多个 Task 调用），或移除并行声明。`,
       }));
       return;
     }
     ```

4. 更新 formatBlockMessage 支持 expected_parallel 和 actual_task_calls 字段（可选）
  </action>
  <verify>
模拟测试：
- 声称 4 个，实际 1 次 Task => block
- 声称 4 个，实际 2 次 Task => pass（容忍部分并行）
- 声称 4 个，实际 4 次 Task => pass
- 无并行声明，1 次 Task => pass
  </verify>
  <done>
validateParallelCalls() 正确检测完全欺骗并容忍部分并行
  </done>
</task>

</tasks>

<verification>
1. 端到端模拟测试：
   - 构造 UserPromptSubmit 输入带"并行启动 4 个 researcher"
   - 构造 1 次 PreToolUse Task 调用
   - 构造 Stop 事件
   - 确认输出 decision=block + error_code=USER_FAKE_PARALLEL

2. 边界情况测试：
   - 无并行声明 + 1 次 Task => 不拦截
   - 并行声明 + 0 次 Task => 不拦截（由 required_subagent 校验处理）
   - 并行声明 + 2 次 Task => 不拦截（容忍部分并行）
</verification>

<success_criteria>
- [ ] extractParallelClaim() 正确提取中英文并行声明
- [ ] handlePreToolUse 累加 task_call_count
- [ ] validateParallelCalls() 仅拦截完全欺骗（声称 N 但只有 1）
- [ ] handleStop 在适当位置调用并行校验
- [ ] 阻止消息包含清晰的修复建议
</success_criteria>

<output>
After completion, create `.planning/phases/02-advanced-detection-configuration/02-02-SUMMARY.md`
</output>
